[1mdiff --git a/src/experiments/experiment.py b/src/experiments/experiment.py[m
[1mindex 3a79472..c7e665f 100644[m
[1m--- a/src/experiments/experiment.py[m
[1m+++ b/src/experiments/experiment.py[m
[36m@@ -46,7 +46,7 @@[m [mclass experiment():[m
         self.useFBO = False[m
 [m
         self.FR = 0 #frame rate of the stimulus window[m
[31m-[m
[32m+[m[41m                [m
         #Load previously saved experimental settings from configOptions.json[m
         if Path('configOptions.json').is_file():[m
             with open('configOptions.json') as f:[m
[36m@@ -94,7 +94,6 @@[m [mclass experiment():[m
         '''[m
         Begin the experiment[m
         '''[m
[31m-[m
         self.win = visual.Window([m
                     allowGUI=self.allowGUI,[m
                     monitor = self.stimMonitor,[m
[36m@@ -173,3 +172,4 @@[m [mclass experiment():[m
 [m
         if self.useInformationMonitor:[m
             self.informationWin.close()[m
[41m+            [m
\ No newline at end of file[m
[1mdiff --git a/src/main.py b/src/main.py[m
[1mindex 9c9cbb5..9731ea8 100644[m
[1m--- a/src/main.py[m
[1m+++ b/src/main.py[m
[36m@@ -38,7 +38,7 @@[m [mfrom protocols.CheckerboardReceptiveField import CheckerboardReceptiveField[m
 from protocols.MovingGratingDirection import MovingGratingDirection[m
 from protocols.OscillatingGrating import OscillatingGrating[m
 from protocols.PupilCalibration import PupilCalibration[m
[31m-[m
[32m+[m[32mfrom protocols.StaticGrating import StaticGrating[m
 [m
 [m
 class Bassoon:[m
[36m@@ -971,7 +971,7 @@[m [mclass Bassoon:[m
             self.saveExperimentButton.configure(bg=_from_rgb((100, 200, 100)))[m
         except:[m
             print('It looks like the Bassoon GUI is not accessable... if it has already closed then you can ignore this message')[m
[31m-[m
[32m+[m[41m            [m
 [m
     def runExperiment(self):[m
         '''[m
[1mdiff --git a/src/protocols/OscillatingGrating.py b/src/protocols/OscillatingGrating.py[m
[1mindex 06d0c35..7c0b119 100644[m
[1m--- a/src/protocols/OscillatingGrating.py[m
[1m+++ b/src/protocols/OscillatingGrating.py[m
[36m@@ -26,7 +26,7 @@[m [mclass OscillatingGrating(protocol):[m
         self.gratingOrientations = [90.0, 270.0] #degrees[m
         self.gratingTexture = 'sin' #can be 'sin', 'sqr', 'saw', 'tri', None[m
         self.oscillationPeriod = 10.0 #seconds[m
[31m-        self.oscillationAmplitude = 10.0 #visual degrees - distance that the grating moves over the course of one oscillation[m
[32m+[m[32m        self.oscillationAmplitude = 10.0 #visual degrees - distance that the grating moves over the course of one half oscillation[m
         self.oscillationPhaseShift = 0.0 #degrees - between 0 and 90 - 90 will start the oscillation in the middle of it's cycle. 0 will start it all the way on one side[m
         self.backgroundColor = [0.0, 0.0, 0.0][m
         self.stimulusReps = 3[m
[1mdiff --git a/src/protocols/StaticGrating.py b/src/protocols/StaticGrating.py[m
[1mnew file mode 100644[m
[1mindex 0000000..b09e18a[m
[1m--- /dev/null[m
[1m+++ b/src/protocols/StaticGrating.py[m
[36m@@ -0,0 +1,184 @@[m
[32m+[m[32m# -*- coding: utf-8 -*-[m
[32m+[m[32m"""[m
[32m+[m[32mCreated on Tue Mar  1 19:57:01 2022[m
[32m+[m
[32m+[m[32m@author: mrsco[m
[32m+[m[32m"""[m
[32m+[m
[32m+[m[32m# -*- coding: utf-8 -*-[m
[32m+[m[32m"""[m
[32m+[m[32mCreated on Mon Jul 12 16:17:29 2021[m
[32m+[m
[32m+[m[32mGrating moves across the screen in directions specified in orientations parameter.[m
[32m+[m[32mOrder is random.[m
[32m+[m
[32m+[m[32m@author: mrsco[m
[32m+[m[32m"""[m
[32m+[m[32mfrom protocols.protocol import protocol[m
[32m+[m[32mfrom psychopy import core, visual, data, event, monitors[m
[32m+[m[32mimport serial, random, math[m
[32m+[m
[32m+[m[32mclass StaticGrating(protocol):[m
[32m+[m[32m    def __init__(self):[m
[32m+[m[32m        super().__init__()[m
[32m+[m[32m        self.protocolName = 'MovingGratingDirection'[m
[32m+[m[32m        self.gratingColor = [1.0, 1.0, 1.0][m
[32m+[m[32m        self.gratingContrast = 1.0 #multiplied by the color[m
[32m+[m[32m        self.meanIntensity = 0.0; #mean intensity of the grating[m
[32m+[m[32m        self.spatialFrequency = 0.1 #cycles per degree[m
[32m+[m[32m        self.gratingTexture = 'sin' #can be 'sin', 'sqr', 'saw', 'tri', None[m
[32m+[m[32m        self.orientations = [float(x*45) for x in range(8)] #list of floats - degrees[m
[32m+[m[32m        self.backgroundColor = [0.0, 0.0, 0.0][m
[32m+[m[32m        self.stimulusReps = 3[m
[32m+[m[32m        self.preTime = 20.0 #s[m
[32m+[m[32m        self.stimTime = 1.0 #s[m
[32m+[m[32m        self.tailTime = 1.0 #s[m
[32m+[m[32m        self.interStimulusInterval = 1.0 #s - wait time between each stimulus. backGround color is displayed during this time[m
[32m+[m[32m        self._angleOffset = 0.0 # reassigned by the experiment in most cases[m
[32m+[m
[32m+[m[32m    def estimateTime(self):[m
[32m+[m[32m        '''[m
[32m+[m[32m        Estimate the total amount of time that this protocol will take to run[m
[32m+[m[32m        given the current parameters[m
[32m+[m
[32m+[m[32m        Value is stored as total time in seconds in the property 'self.estimatedTime'[m
[32m+[m[32m        which is initialized by the protocol superclass.[m
[32m+[m
[32m+[m[32m        returns: estimated time in seconds[m
[32m+[m[32m        '''[m
[32m+[m[32m        timePerEpoch = self.preTime + self.stimTime + self.tailTime + self.interStimulusInterval[m
[32m+[m[32m        numberOfEpochs = self.stimulusReps * len(self.orientations)[m
[32m+[m[32m        self._estimatedTime = timePerEpoch * numberOfEpochs #return estimated time for the total stimulus in seconds[m
[32m+[m
[32m+[m[32m        return self._estimatedTime[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m    def createOrientationLog(self):[m
[32m+[m[32m        '''[m
[32m+[m[32m        Generate a random sequence of orientations given the desired orientations[m
[32m+[m
[32m+[m[32m        Desired orientations are specified as a list in self.orientations[m
[32m+[m
[32m+[m[32m        creates self._orientationLog, a list, which specifies the orienation[m
[32m+[m[32m        to use for each epoch[m
[32m+[m[32m        '''[m
[32m+[m[32m        orientations = self.orientations[m
[32m+[m[32m        self._orientationLog = [][m
[32m+[m[32m        random.seed(self.randomSeed) #reinitialize the random seed[m
[32m+[m
[32m+[m[32m        for n in range(self.stimulusReps):[m
[32m+[m[32m            self._orientationLog += random.sample(orientations, len(orientations))[m
[32m+[m
[32m+[m
[32m+[m[32m    def run(self, win, informationWin):[m
[32m+[m[32m        '''[m
[32m+[m[32m        Executes the MovingBar stimulus[m
[32m+[m[32m        '''[m
[32m+[m
[32m+[m[32m        self._completed = 0 #started but not completed[m
[32m+[m
[32m+[m[32m        self._informationWin = informationWin #tuple, save here so you don't have to pass this as a function parameter every time you use it[m
[32m+[m
[32m+[m
[32m+[m[32m        self.getFR(win)[m
[32m+[m[32m        self._interStimulusIntervalNumFrames = round(self._FR * self.interStimulusInterval)[m
[32m+[m[32m        self._actualInterStimulusInterval = self._interStimulusIntervalNumFrames * 1/self._FR[m
[32m+[m
[32m+[m[32m        stimMonitor = win.monitor[m
[32m+[m[32m        pixPerDeg = self.getPixPerDeg(stimMonitor)[m
[32m+[m
[32m+[m[32m        #Pause for keystroke if the user wants to manually initiate[m
[32m+[m[32m        if self.userInitiated:[m
[32m+[m[32m            self.showInformationText(win, 'Stimulus Information: Static Grating\nPress any key to begin')[m
[32m+[m[32m            event.waitKeys() #wait for key press[m
[32m+[m
[32m+[m[32m        spatialFrequencyCyclesPerPixel = self.spatialFrequency * (1/pixPerDeg)[m
[32m+[m
[32m+[m[32m        grating = visual.GratingStim([m
[32m+[m[32m            win,[m
[32m+[m[32m            size = (win.size[0]*2, win.size[1]*2),[m
[32m+[m[32m            sf = (spatialFrequencyCyclesPerPixel, None),[m
[32m+[m[32m            tex = self.gratingTexture,[m
[32m+[m[32m            contrast = self.gratingContrast,[m
[32m+[m[32m            color = self.gratingColor[m
[32m+[m[32m            )[m
[32m+[m
[32m+[m
[32m+[m[32m        #The cover rectangle is drawn on top of the primary grating. It is used[m
[32m+[m[32m        #to change the mean intensity of the grating when the user desires.[m
[32m+[m[32m        #If the mean intensity is set to 0, then the cover rectangle is still[m
[32m+[m[32m        #drawn but with an opacity of 0[m
[32m+[m[32m        coverRectangle = visual.Rect([m
[32m+[m[32m            win,[m
[32m+[m[32m            size = (win.size[0]*2, win.size[1]*2),[m
[32m+[m[32m            opacity = 0[m
[32m+[m[32m            )[m
[32m+[m
[32m+[m[32m        if self.meanIntensity > 0:[m
[32m+[m[32m            coverRectangle.fillColor = [1, 1, 1][m
[32m+[m[32m            coverRectangle.opacity = self.meanIntensity[m
[32m+[m[32m        elif self.meanIntensity < 0:[m
[32m+[m[32m            coverRectangle.fillColor = [-1, -1, -1][m
[32m+[m[32m            coverRectangle.opacity = -1*self.meanIntensity[m
[32m+[m
[32m+[m
[32m+[m[32m        self.createOrientationLog()[m
[32m+[m
[32m+[m[32m        totalEpochs = len(self._orientationLog)[m
[32m+[m[32m        epochNum = 0[m
[32m+[m[32m        trialClock = core.Clock() #this will reset every trial[m
[32m+[m
[32m+[m[32m        #stimulus loop[m
[32m+[m[32m        for ori in self._orientationLog:[m
[32m+[m[32m            grating.ori = -ori - self._angleOffset #flip for coordinate convention: 0 = east, 90 = north, 180 = west, 270 = south[m
[32m+[m[32m            epochNum += 1[m
[32m+[m[32m            #show information if necessary[m
[32m+[m[32m            if self._informationWin[0]:[m
[32m+[m[32m                self.showInformationText(win, 'Running Static Grating Direction. Current orientation = ' + \[m
[32m+[m[32m                                         str(ori) + '\n Epoch ' + str(epochNum) + ' of ' + str(totalEpochs))[m
[32m+[m
[32m+[m
[32m+[m[32m            #pause for inter stimulus interval[m
[32m+[m[32m            win.color = self.backgroundColor[m
[32m+[m[32m            for f in range(self._interStimulusIntervalNumFrames):[m
[32m+[m[32m                win.flip()[m
[32m+[m[32m                if self.checkQuit():[m
[32m+[m[32m                    return[m
[32m+[m
[32m+[m[32m            #pretime... stationary grating[m
[32m+[m[32m            self._stimulusStartLog.append(trialClock.getTime())[m
[32m+[m[32m            self.sendTTL()[m
[32m+[m[32m            self._numberOfEpochsStarted += 1[m
[32m+[m[32m            for f in range(self._preTimeNumFrames):[m
[32m+[m[32m                grating.draw()[m
[32m+[m[32m                coverRectangle.draw()[m
[32m+[m[32m                win.flip()[m
[32m+[m[32m                if self.checkQuit():[m
[32m+[m[32m                    return[m
[32m+[m
[32m+[m[32m            #stim time - flash[m
[32m+[m[32m            for f in range(self._stimTimeNumFrames):[m
[32m+[m[32m                grating.draw()[m
[32m+[m[32m                coverRectangle.draw()[m
[32m+[m[32m                win.flip()[m
[32m+[m[32m                if self.checkQuit():[m
[32m+[m[32m                    return[m
[32m+[m
[32m+[m[32m            #tail time[m
[32m+[m[32m            for f in range(self._tailTimeNumFrames):[m
[32m+[m[32m                grating.draw()[m
[32m+[m[32m                coverRectangle.draw()[m
[32m+[m[32m                win.flip()[m
[32m+[m[32m                if self.checkQuit():[m
[32m+[m[32m                    return[m
[32m+[m
[32m+[m
[32m+[m[32m            self._stimulusEndLog.append(trialClock.getTime())[m
[32m+[m[32m            self.sendTTL()[m
[32m+[m[32m            win.flip();win.flip() #two flips to allow for a pause for TTL writing[m
[32m+[m
[32m+[m[32m            self._numberOfEpochsCompleted += 1[m
[32m+[m
[32m+[m
[32m+[m[32m        self._completed = 1[m
